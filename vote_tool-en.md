# **vote_tool**

## Summary
This is a sample code for providing an e-voting scheme.

This scheme is used under the assumption that each voter encrypts either a '0' or '1' and individually sends his/her ciphertext to the server, and the server calculates the results without knowing each vote nor the results themselves.
The sample code emulates the scheme.

Note that the sample code is written only for the purpose of giving an example of the library usage, and is not appropriate for being used in the real world.

## Commandline options

   vote_tool.exe [opt] mode
   mode: select any one of init/vote/count/open
   -l: input a bit vector

# vote_tool.exe init
Initialization of the system and generation of a public key (vote_pub.txt) and a secret key (vote_prv.txt).
secp192k1 is used as a parameter of the EC-ElGamal encryption.

# vote_tool.exe vote [-l a bit vector]
Input a bit vector v of length n
v[i] is the i-th voter's vote

The program encrypts v[i] for i=0,...,n by using the public key, and shuffles the order of the sequence of ciphertexts.
It then stores each ciphertext in any one of vote_0.txt,...,vote_n.txt.
Since the order is shuffled, the server is not able to detect which file includes who's vote.
This process emulates that each voter individually sends a ciphertext encrypted using his/her own public key.

# vote_tool.exe count
The program reads all the ciphertexts from the files and checks whether or not each of them is generated by encrypting either a '0' or '1' without decrypting it.
This is done by using the non-interactive zero knowledge proof that is provided by the library.
The program aggregates the votes without decryption after verifying all the ciphertexts.

# vote_tool.exe open
The program decrypts the ciphertext written in result.txt and shows the results on the console.
